#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/titlescreen.h"
#include "images/background.h"
#include "images/asteroid.h"
#include "images/spaceship.h"
#include "images/debris.h"
#include "images/WinScreen.h"
#include "images/losescreen.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int score = 0; 
int timeRemaining = 10; 
u32 lastFrameTime = 0;

Sprite player;
Sprite debrisTrash[DEBRIS_COUNT];
Sprite asteroids[ASTEROID_COUNT];

char buffer[50];

// Forward declarations for functions that might be missing
void fillScreenDMA(volatile u16 color);
int randint(int min, int max);

void initializeGame(void) {

    score = 0; 
    timeRemaining = 10;
    lastFrameTime = vBlankCounter;  

    player.row = HEIGHT / 2 - PLAYER_HEIGHT / 2;
    player.col = WIDTH / 2 - PLAYER_WIDTH / 2;
    player.rDel = 2;
    player.cDel = 2;
    player.width = PLAYER_WIDTH;
    player.height = PLAYER_HEIGHT;
    player.active = 1;
    
    // Initialize debris
    for (int i = 0; i < DEBRIS_COUNT; i++) {
        debrisTrash[i].width = DEBRIS_WIDTH;
        debrisTrash[i].height = DEBRIS_HEIGHT;
        debrisTrash[i].row = randint(0, HEIGHT - DEBRIS_HEIGHT);
        debrisTrash[i].col = randint(0, WIDTH - DEBRIS_WIDTH);
        debrisTrash[i].active = 1;
    }
    
    // Initialize asteroids
    for (int i = 0; i < ASTEROID_COUNT; i++) {

        asteroids[i].width = ASTEROID_WIDTH;
        asteroids[i].height = ASTEROID_HEIGHT;
        asteroids[i].row = randint(0, HEIGHT - ASTEROID_HEIGHT);
        asteroids[i].col = randint(0, WIDTH - ASTEROID_WIDTH);
        asteroids[i].rDel = randint(-1, 2);
        asteroids[i].cDel = randint(-1, 2);
        
        if (asteroids[i].rDel == 0) asteroids[i].rDel = 1;
        if (asteroids[i].cDel == 0) asteroids[i].cDel = 1;
        
        asteroids[i].active = 1;
    }
}

int checkCollision(Sprite s1, Sprite s2) {
    return (s1.col < s2.col + s2.width && s1.col + s1.width > s2.col && s1.row < s2.row + s2.height && s1.row + s1.height > s2.row);
}

//This is the 4 dimensional requirement portion for the player to move
void updateGame(void) {
  if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
    player.row -= player.rDel;
  }

  if (KEY_DOWN(BUTTON_DOWN, BUTTONS)) {
    player.row += player.rDel;
  }

  if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {
    player.col -= player.cDel;
  }

  if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
    player.col += player.cDel;
  }

  // THis part is so that the player doesn't go off the screen:
  if (player.row < 0) {
      player.row = 0;
  }

  if (player.row > HEIGHT - player.height) {
    player.row = HEIGHT - player.height;
  }

  if (player.col < 0) {
    player.col = 0;
  }

  if (player.col > WIDTH - player.width) {
    player.col = WIDTH - player.width;
  }    
  
  //asteroid movement
  for (int i = 0; i < ASTEROID_COUNT; i++) {
    if (asteroids[i].active) {
      asteroids[i].row += asteroids[i].rDel;
      asteroids[i].col += asteroids[i].cDel;
            
    // asteroids bounce off edges
    if (asteroids[i].row <= 0 || asteroids[i].row >= HEIGHT - asteroids[i].height) {
      asteroids[i].rDel = -asteroids[i].rDel;
      }
    if (asteroids[i].col <= 0 || asteroids[i].col >= WIDTH - asteroids[i].width) {
      asteroids[i].cDel = -asteroids[i].cDel;
      }
    }
  }

  // debris collection feature
  for (int i = 0; i < DEBRIS_COUNT; i++) {
    if (debrisTrash[i].active && checkCollision(player, debrisTrash[i])) {
      debrisTrash[i].active = 0;
      score += 10;
      
    // debris respawns if 5 collected
    if (score % 50 == 0) {
        for (int j = 0; j < DEBRIS_COUNT; j++) {
          if (!debrisTrash[j].active) {
            debrisTrash[j].row = randint(0, HEIGHT - debrisTrash[j].height);
            debrisTrash[j].col = randint(0, WIDTH - debrisTrash[j].width);
            debrisTrash[j].active = 1;
          }
        }
      }
    }
  }

  int allDebrisCollected = 1;
  for(int i = 0; i < DEBRIS_COUNT; i++) {
    if (debrisTrash[i].active) {
      allDebrisCollected = 0;
      break;
    }
  }

  if (allDebrisCollected) {
    for(int i = 0; i < DEBRIS_COUNT; i++) {
      debrisTrash[i].row = randint(0, HEIGHT - debrisTrash[i].height);
      debrisTrash[i].col = randint(0, WIDTH - debrisTrash[i].width);
      debrisTrash[i].active = 1; 
    }
  }

  if (vBlankCounter - lastFrameTime >= 30) {
    timeRemaining--;
    lastFrameTime = vBlankCounter;
  }
}


// title start screen
void drawStartScreen(void) {
    drawFullScreenImageDMA(titlescreen_fixed);
    // drawCenteredString(HEIGHT / 2 - 20, 0, WIDTH, 20, "SPACE DEBRIS CLEANUP", WHITE);
    // drawCenteredString(HEIGHT / 2, 0, WIDTH, 20, "Press START to play", WHITE);
    // drawCenteredString(HEIGHT / 2 + 20, 0, WIDTH, 20, "Use D-Pad to move", WHITE);
}

// draw game screen
void drawGameScreen(void) {
    drawFullScreenImageDMA(background);
    drawImageDMA(player.row, player.col, player.width, player.height, spaceship);
    
    for (int i = 0; i < DEBRIS_COUNT; i++) {
      if (debrisTrash[i].active) {
        drawImageDMA(debrisTrash[i].row, debrisTrash[i].col, debrisTrash[i].width, debrisTrash[i].height, debris);
      }
    }
    
    // Draw asteroids
    for (int i = 0; i < ASTEROID_COUNT; i++) {
      if (asteroids[i].active) {
        drawImageDMA(asteroids[i].row, asteroids[i].col, asteroids[i].width, asteroids[i].height, asteroid);
      }
    }
    
    // Draw score and time
    snprintf(buffer, 50, "S: %d", score);
    drawString(5, 5, buffer, WHITE);
    
    snprintf(buffer, 50, "T: %d", timeRemaining);
    drawString(20, 5, buffer, WHITE); 
}

// Draw win screen
void drawWinScreen(void) {
    drawFullScreenImageDMA(winscreen);
    
    snprintf(buffer, 50, "Final Score: %d", score);
    drawCenteredString(HEIGHT / 2 + 25, 0, WIDTH, 20, buffer, WHITE);

}

// Draw lose screen
void drawLoseScreen(void) {
    drawFullScreenImageDMA(losescreen);

    snprintf(buffer, 50, "Final Score: %d", score);
    drawCenteredString(HEIGHT / 2 + 25, 0, WIDTH, 20, buffer, WHITE);
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
    setPixel(80, 120, WHITE);  // center pixel

  // Initialize random seed
  srand(0);

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  initializeGame();

  while (1) {
    currentButtons = BUTTONS;
    
    // Check for SELECT (backspace) button to reset the game at ANY time
    if (KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
      state = START;
      initializeGame();
    }
    
    // Handle state transitions and game logic
    switch (state) {
      case START:
        // Check for START button to begin game
        if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
          state = PLAY;
          initializeGame();
        }
        break;

      case PLAY:
        updateGame();
        
        // Check for collisions with asteroids
        for (int i = 0; i < ASTEROID_COUNT; i++) {
          if (asteroids[i].active && checkCollision(player, asteroids[i])) {
            state = LOSE;
            break;
          }
        }
        
        // Check if time is up
        if (timeRemaining <= 0) {
          if (score >= 50) {
            state = WIN;
          } else {
            state = LOSE;
          }
        }
        break;

      case WIN:
        // Check for START button to play again
        if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
          state = PLAY;
          initializeGame();
        } 
        break;

      case LOSE:
        // Restart the game when START is pressed
        if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
            state = PLAY;
            initializeGame();
        }
        break;
    }

    // Store button state for next frame
    previousButtons = currentButtons;
    
    waitForVBlank();
    
    // Now handle all drawing operations during VBlank
    switch (state) {
      case START:
        // Draw the title screen
        drawStartScreen();
        break;
        
      case PLAY:
        // Draw game screen with all elements
        drawGameScreen();
        break;
        
      case WIN:
        // Draw win screen
        drawWinScreen();
        break;
        
      case LOSE:
        // Draw lose screen
        drawLoseScreen();
        break;
    }
  }

  return 0;
}